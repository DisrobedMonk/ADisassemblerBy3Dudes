*-----------------------------------------------------------
* Title      : Disassembler IO File
* Written by : Torren,Doug,Jeremiah
* Date       : 11/23/2018
* Description:
*-----------------------------------------------------------
START           EQU     $1000
CR              EQU     $0D         * ASCII code for Carriage Return
LF              EQU     $0A         * ASCII code for Line Feed
STACK           EQU     $10000      * Defined location for the stack
LINE_CNT        EQU     $F          * Number of lines to print before pausing
EXIT            EQU     $2700


*   D0:  
*   D1:  
*   D2:  
*   D3:  
*   D4: 
*   !D5: OP_CHECK to I/O RTS holder
*   !D6: Current OP code read from latest Current Address position
*   !D7: The current line being printed (I/O line counter)

*   A0:  
*   A1:  
*   A2:  
*   A3:  
*   A4:  
*   !A5: Current Address;   DO NOT ALTER (Initialized via start up requests
*           - except for when in EA to get more information
*   !A6: End Address;       DO NOT ALTER (Initialized via start up requests)
*   !A7: STACK POINTER;     DO NOT ALTER
*           - except in adding or taking from stack






        ORG    START
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *
*
*       Hard coded start and end address
*           Uncomment to test against entered OP code from above test section
*
*        LEA     #0,A5
*        LEA     <ending address>,A6                * Make sure to include the extra address bytes if necessary for your test
*        MOVE.W  #$<put the #$hex of your OP/EA you are testing here>,$0
*        MOVE.L  #$<if needing more information, such as the EA data, put it here>,$<make sure this is the sequential position after what was moved above>
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *





*-----------------I/O code----------------

*---Positioning the stack---
        LEA     STACK,SP        * Position the stack
                
        
*-------Moving on to decoding; start with instructions-------        
BEGIN
        LEA     INSTRCTNS,A1    * Load instruction to inform user how disassembler will work
        MOVE.B  #14,D0
        TRAP    #15
        
        MOVE.L  #0,A1           * Clear A1 to ensure instructions not overwritten

*-------Pause and wait for user to continue------------------
WAIT
        MOVE.L  #5,D0           * Pause for 'enter' by user to move forward
        TRAP    #15             *   A char is actually taken in for D1
        
        CLR.L   D1           * Remove possible garbage intake from 'enter'
        CLR.L   D7           * Zero the line counter
        CLR.L   D0           * All Dr zeroed for a clean run

*---Check if done or perform next line's disassembly---------
SEE_IF_DONE
        CMP     A5,A6           * Check if Current Address is past End Address
        BLT     DONE            * Branch to DONE if completed
        
        CMP.L   #15,D7          * Check if we have printed 15 lines
        BEQ     WAIT            * Await 'Enter' before continuing if so
        
        MOVE.W  (A5)+,D6        * Take the next word of instruction into Current OPcode and increment Current address
        
        JSR     OP_CHECK        * Jump to the OP_CHECK code
                                * Sending:      A0-A4:  Empty
                                *               A5:     The Current Address (just after Current OPcode)
                                *                           Alter this only if more information deemed necessary via OPcode/EAcode
                                *               !A6:    The End Address (DO NOT TOUCH)
                                *               A7:     The current stack position
                                *                           Alter this in order to maintain RTS position and to prepare print statement for OPcode's line
                                *               D0-D5:  Empty
                                *               !D6:    The current OPcode being worked (DO NOT TOUCH)
                                *               !D7:    The current count of lines printed (DO NOT TOUCH)
                                *
                                * Need back:    A0-A4:  Garbage - anything is fine as these will be cleared
                                *               A5:     The Current Address from which the next OPcode will be read
                                *               !A6:    The End Address
                                *               A7:     The current stack position
                                *                           Should have the start of the OPcode's string to be printed and end with "'CR','LF',0"
                                *               D0-D5:  Garbage - anything is fine as these will be cleared
                                *               D6:     Unneeded / was the just completed OPcode
                                *               !D7:    The current count of lines printed
        
        
        MOVE.L  #14,D0           * Prep for printing the just disassembled OPcode
        
        MOVE.L  SP,A1
        TRAP    #15
        
        LEA     STACK,SP
        
        CLR.L   D1           * Clear the unnecessasry registers for further use
        CLR.L   D2
        CLR.L   D3
        CLR.L   D4
        CLR.L   D5
        CLR.L   D6
        MOVE.L  #0,A0
        MOVE.L  #0,A1
        MOVE.L  #0,A2
        MOVE.L  #0,A3
        MOVE.L  #0,A4
        
        ADD.L   #1,D7
        
        BRA     SEE_IF_DONE


*---------Branch to when Current Address past End Address-----
DONE
    STOP    #EXIT               * Done, thus exit











* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *
OP_CHECK

    * PLACEHOLDER FOR ACTUAL OP CODE ELSEWHERE
    *
    * Put your own code here to test it
    
    
    * Flow should be:
    *
    * Copy D6 into D5
    * Mutate/bit mask D5 with what you're looking for
    * CMP what you're looking for with D5
    * BEQ to an <OP code name here>_FOUND section
    *
    * Rinse and repeat the above 4 lines with next CMP happening
    * again
    * and again
    * ...
    *
    * AFTER all compares:
    * Put your <OP code name here>_FOUND code block here
    * Should go:
    * JSR <OP code name here>_EA
    * RTS
    
    
    RTS 
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *





* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *
*_YOUR_EA_CODE_TESTING_FROM_THE_OP_CHECK_ABOVE_
    
    * SELF EXPLANATORY ADDITIONAL TESTING AREA
    * 
    * Replace the name and test your I/O -> OP_CHECK -> EA code here
    
    
    * Flow should be:
    *
    * Find if need more data
    * Get it if so
    * Move RTS code of EA->OP into D5
    * Move RTS code of OP->I/O into D4
    * Do some magic (convert the OP code + possible extra data into ASCII)
    * Move each ASCII portion onto the stack (Move as word or long, not byte)
    * Move RTS code of OP->I/O onto stack
    * Move RTS code of EA->OP onto stack
    * RTS


* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! *











* Variables and defined constraints

STRT_RQST   DC.B    'Please provide a valid starting hex address for the code to be disassembled.',CR,LF
            DC.B    'Invalid entry will only lead to the question being repeated.',CR,LF
            DC.B    'Only numbers 0-9 and capitals A-F are accepted.',CR,LF
            DC.B    'Starting address must also be even.',CR,LF
                                                                          * There's a chance we also want to iron out and check to ensure it's not our own code?
            DC.B    'What will the starting address be?',CR,LF,0 
            
END_RQST    DC.B    'Thank you for the starting address.',CR,LF
            DC.B    'Please now provide an end address.',CR,LF
            DC.B    'Invalid entry will only lead to the question being repeated.',CR,LF
            DC.B    'Only numbers 0-9 and capitals A-F are accepted.',CR,LF
                                                                          * There's a chance we also want to iron out and check to ensure it's not our own code?
            DC.B    'What will the ending address be?',CR,LF,0
            
INSTRCTNS   DC.B    'We are ready to begin reading the code between the given starting and end addresses.',CR,LF
            DC.B    'While running, the program will pause every fifteen lines.',CR,LF
            DC.B    'To continue, press the "Enter" key.',CR,LF
            DC.B    'Do so now to begin.',CR,LF,0



    END    START        ; last line of source


